"""
Decorator utilities to inject limits into `APIRoute` objects.
"""

from typing import Annotated, Any, Callable, ParamSpec, TypeVar

from fastapi import Depends
from fastapi.dependencies.utils import get_parameterless_sub_dependant
from fastapi.utils import create_model_field
from limits import parse
from typing_extensions import Doc

from .dependencies import BaseLimiterDependency, _InjectedLimiterDependency
from .exceptions import TooManyRequests
from .types import CallableFilter, SupportsRoutes
from .utils import create_response_model, find_api_route

P = ParamSpec("P")
R = TypeVar("R")

_default_429_response = {
    "model": TooManyRequests,
    "headers": {
        "retry_after": {"description": "Retry after n seconds", "type": "integer"}
    },
}


def limit(
    router: Annotated[
        SupportsRoutes,
        Doc(
            """
The FastAPI or APIRouter object that was used to add this route.

e.g. 'app' in this example:

```
app = FastAPI()

@app.get("/")
async def some_route(...):
    ...
```
    """
        ),
    ],
    limit_string: Annotated[
        str,
        Doc(
            """
The limit to be applied to this route as string.

for example `5/minute` will be 5 requests per minute.
"""
        ),
    ],
    key: Annotated[
        str | None,
        Doc(
            """
the unique key to be used for this route.

you can apply limits to routes using a shared key, all these routes limits will be calculated together.

for example if you use the same keys for 'POST /items' and 'GET /items', rate limit will hit on that key with calling any of them.
"""
        ),
    ] = None,
    filters: Annotated[
        CallableFilter | list[CallableFilter] | None,
        Doc(
            """
Filters to check before counting a hit.

It has to be a function or async function that returns a bool.

a hit will be counted if all of the filters return True.

you can use Depends for filters and they will be resolved by FastAPI automatically.

for example:

```
def normal_user_filter(user: Depends(get_current_user)) -> bool:
    if user.role == "user":
        return True
    return False


@limit(app, "5/minute", filters=normal_user_filter)
@app.get("/items"):
    ...
```
in this example the limit will only be applied to users with role of 'user'.
"""
        ),
    ] = None,
    no_hit_status_codes: Annotated[
        list[int] | None,
        Doc(
            """
a list of status codes to not count a hit when they are returned.

for example if you pass `[400, 404]`, if the response status code was in the list, a hit will not be counted.
"""
        ),
    ] = None,
    default_response_model: Annotated[
        dict[str, Any] | None,
        Doc(
            """
default response model to use for 429 responses in the autogenerated docs.

if `None` was passed, nothing will be shown in the docs about this response.
"""
        ),
    ] = _default_429_response,
    show_limit_in_response_model: Annotated[
        bool,
        Doc(
            """
Should the values for rate-limit be shown in the response model?
        
if set to True, something like this will be shown in the docs:

```
{
  "detail": "Rate limit exceeded: 5 per 1 minute"
}
```

    and else:
    
```
{
  "detail": "Rate limit exceeded: {x} per {y} {granularity}"
}
```
        """
        ),
    ] = True,
) -> Callable[[Callable[P, R]], Callable[P, R]]:
    """
    A decorator that injects a dependency into the 'APIRoute' object and that dependency handles the rate-limiting job.
    """

    def decorator(func: Callable[P, R]) -> Callable[P, R]:
        route = find_api_route(router, func)
        if route:
            item = parse(limit_string)
            if default_response_model is not None:
                route.responses[429] = default_response_model
                if (model := route.responses[429].get("model", None)) is not None:
                    route.response_fields[429] = create_model_field(
                        name=f"Response_429_{route.unique_id}",
                        type_=create_response_model(
                            model, item, show_limit_in_response_model
                        ),
                    )
            dep_class = BaseLimiterDependency
            if filters:
                dep_class = _InjectedLimiterDependency.apply_dependencies(filters)
            limit_dependency = Depends(
                dep_class(
                    limit_value=item,
                    key=key,
                    no_hit_status_codes=no_hit_status_codes,
                )
            )
            route.dependant.dependencies.insert(
                0,
                get_parameterless_sub_dependant(
                    depends=limit_dependency,
                    path=route.path_format,
                ),
            )
        return func

    return decorator
