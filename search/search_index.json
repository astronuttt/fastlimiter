{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastLimiter","text":"<p> [WIP] FastLimiter is a rate limiting extension/middleware for FastAPI applications powered by limits. </p> <p>Documentation: https://astronuttt.github.io/fastlimiter</p> <p>Source Code: https://github.com/astronuttt/fastlimiter</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>FastAPI depencies support: FastAPI dependencies can be used in limiters to apply limits based on the injected dependency.</p> </li> <li> <p>Automatic documentation for additional responses: It will automatically add additional <code>429_TOO_MANY_REQUESTS</code> response to the schema, so it can be used in the generated documentation.</p> </li> <li> <p>Middlewares support: Can act as a middleware to apply limits to all the routes and etc.</p> </li> <li> <p>Partial and full limits: limits can be applied to an <code>APIRouter</code> the whole <code>FastAPI</code> app or a single route operation.</p> </li> <li> <p>Exclude certain responses: certain responses can be excluded from the limitation. for example, you can exclude <code>400</code> status codes and if the route returns a <code>400</code> it won't be counted for limitations.</p> </li> <li> <p>Limit groups: You can apply a group of limits, for example a certain limit for admin users, and a certain limit for normal users.</p> </li> <li> <p>Multiple limit strategies: It uses the limits library on the back-end so it supports multiple strategies. see Supported Strategies.</p> </li> <li> <p>Multiple Storage backends: As another perk of the limits library, multiple storage backends are supported. see Storage backends</p> </li> </ul>"},{"location":"#how-it-works","title":"How it works","text":"<p>It uses the limits library in the backend for all the limitation handlings.</p> <p>As for the <code>FastAPI</code> side it Injects a dependency into the <code>APIRoute</code> object and that dependency acts as the main component for limitation on that route. one of it's perks are that you can apply some limitations based on a <code>Depends</code> and everything will be handled automatically by <code>FastAPI</code>.</p>"},{"location":"#other-limit-libraries","title":"Other limit libraries","text":"<p>Some of the ideas for this library comes from two great libraries that were created before this:</p> <p>SlowApi: https://github.com/laurents/slowapi</p> <p>fastapi-limiter: https://github.com/long2ice/fastapi-limiter</p> <p>These are two great libraries, but each of them lack some functionality, so I decided to extend them and create FastLimiter.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>This library works by a combination of a dependency and a middleware, but using it is very simple.</p> <p>First step is to setup the <code>Limiter</code> and then add the limiting middleware to your <code>FastAPI</code> application.</p> <pre><code>from fastapi import FastAPI\n\n# The simplest setup is to use 'MemoryStorage' and 'FixedWindowRateLimiter', you don't even have to specify these because it's the default\nfrom limits.aio.storage import MemoryStorage\nfrom limits.aio.strategies import FixedWindowRateLimiter\n\nfrom fastlimiter import RateLimitingMiddleware, limit\n\n\napp = FastAPI()\n\n\nlimiter = FixedWindowRateLimiter(storage=MemoryStorage())\napp.add_middleware(RateLimitingMiddleware, strategy=limiter)\n\n# and thats for the setup! you can now use the 'limit' decorator to apply limits on any route\n\n@limit(app, \"5/minute\")\n@app.get(\"/\")\nasync def items(q: int | None = None):\n    return {\"q\": q}\n</code></pre> <p>And thats it! now users can call the GET 'items' route only 5 times per minute.</p> <p>For more usage please refer to the documentation at https://astronuttt.github.io/fastlimiter</p> <p>This library inherits most of it's functionality from limits. special thanks to the everyone who helped make that happen.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"api-refrence/dependencies/","title":"Dependencies","text":""},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.BaseLimiterDependency","title":"BaseLimiterDependency","text":"<p>This dpendency will be injected into the <code>APIRoute</code> object and does the actual 'limiting' job.</p> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>class BaseLimiterDependency:\n    \"\"\"\n    This dpendency will be injected into the `APIRoute` object and does the actual 'limiting' job.\n    \"\"\"\n\n    def __init__(\n        self,\n        limit_value: str | RateLimitItem,\n        no_hit_status_codes: list[int] | None = None,\n    ) -&gt; None:\n        \"\"\"BaseLimiterDependency\n\n        Args:\n            limit_value (str | RateLimitItem): a string like \"5/minute\" or a `RateLimitItem` object\n            no_hit_status_codes (list[int] | None, optional): the response statuses that won't be count as a hit on the limiter.\n        \"\"\"\n        if isinstance(limit_value, str):\n            self.item = parse(limit_value)\n        else:\n            self.item = limit_value\n        self.no_hit_status_codes = no_hit_status_codes if no_hit_status_codes else []\n\n    async def __call__(\n        self,\n        request: Request,\n        response: Response,\n        keys: list[str] | None = None,\n    ) -&gt; None:\n        \"\"\"The actual callable that FastAPI call and checks for rate-limiting\n\n        Args:\n            request (Request): request object from FastAPI\n            response (Response): response object from FastAPI\n            keys (list[str] | None, optional): extra keys other than those provided by the middleware as identifiers for a rate-limit item\n\n        Raises:\n            RateLimitExceeded: when the rate limit exceeds the allowed value\n        \"\"\"\n        # TODO: do not check other filters if one accepted\n        try:\n            limiter: \"RateLimitingMiddleware\" = request.state.limiter\n        except AttributeError:\n            return\n        built_keys = await self._build_key(\n            limiter.keys, request, keys\n        )  # resolve middleware level keys and append endpoint level keys\n        if not await limiter.strategy.test(self.item, *built_keys):\n            raise RateLimitExceeded(\n                limit=self.item, detail=f\"Rate limit exceeded: {self.item}\"\n            )\n        request.state.limit = self\n        request.state.limit_keys = built_keys\n\n    async def _build_key(\n        self,\n        keys: list[CallableMiddlewareKey],\n        request: Request,\n        extra_keys: list[str] | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Build an identifier for a rate-limit item\n\n        Args:\n            key_funcs (Sequence[CallableOrAwaitableCallable]): a list of keys passed to the `RateLimitingMiddleware` and the dependency itself. these keys will form a identifier for a limit item.\n            request (Request): this has to be changed so keys will also work with Depends\n            extra_keys (list[str] | None, optional): endpoint level keys resolved as strings\n\n        Returns:\n            list[str]: a list containing string keys from the provided callables\n        \"\"\"\n        _keys = [\n            f(request) if not asyncio.iscoroutinefunction(f) else await f(request)\n            for f in keys\n        ]\n        if extra_keys:\n            _keys.extend(extra_keys)\n        return _keys  # type: ignore\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.BaseLimiterDependency.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item = parse(limit_value)\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.BaseLimiterDependency.no_hit_status_codes","title":"no_hit_status_codes  <code>instance-attribute</code>","text":"<pre><code>no_hit_status_codes = (\n    no_hit_status_codes if no_hit_status_codes else []\n)\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.BaseLimiterDependency.__init__","title":"__init__","text":"<pre><code>__init__(\n    limit_value: str | RateLimitItem,\n    no_hit_status_codes: list[int] | None = None,\n) -&gt; None\n</code></pre> <p>BaseLimiterDependency</p> <p>Parameters:</p> Name Type Description Default <code>limit_value</code> <code>str | RateLimitItem</code> <p>a string like \"5/minute\" or a <code>RateLimitItem</code> object</p> required <code>no_hit_status_codes</code> <code>list[int] | None</code> <p>the response statuses that won't be count as a hit on the limiter.</p> <code>None</code> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>def __init__(\n    self,\n    limit_value: str | RateLimitItem,\n    no_hit_status_codes: list[int] | None = None,\n) -&gt; None:\n    \"\"\"BaseLimiterDependency\n\n    Args:\n        limit_value (str | RateLimitItem): a string like \"5/minute\" or a `RateLimitItem` object\n        no_hit_status_codes (list[int] | None, optional): the response statuses that won't be count as a hit on the limiter.\n    \"\"\"\n    if isinstance(limit_value, str):\n        self.item = parse(limit_value)\n    else:\n        self.item = limit_value\n    self.no_hit_status_codes = no_hit_status_codes if no_hit_status_codes else []\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.BaseLimiterDependency.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(\n    request: Request,\n    response: Response,\n    keys: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>The actual callable that FastAPI call and checks for rate-limiting</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>request object from FastAPI</p> required <code>response</code> <code>Response</code> <p>response object from FastAPI</p> required <code>keys</code> <code>list[str] | None</code> <p>extra keys other than those provided by the middleware as identifiers for a rate-limit item</p> <code>None</code> <p>Raises:</p> Type Description <code>RateLimitExceeded</code> <p>when the rate limit exceeds the allowed value</p> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>async def __call__(\n    self,\n    request: Request,\n    response: Response,\n    keys: list[str] | None = None,\n) -&gt; None:\n    \"\"\"The actual callable that FastAPI call and checks for rate-limiting\n\n    Args:\n        request (Request): request object from FastAPI\n        response (Response): response object from FastAPI\n        keys (list[str] | None, optional): extra keys other than those provided by the middleware as identifiers for a rate-limit item\n\n    Raises:\n        RateLimitExceeded: when the rate limit exceeds the allowed value\n    \"\"\"\n    # TODO: do not check other filters if one accepted\n    try:\n        limiter: \"RateLimitingMiddleware\" = request.state.limiter\n    except AttributeError:\n        return\n    built_keys = await self._build_key(\n        limiter.keys, request, keys\n    )  # resolve middleware level keys and append endpoint level keys\n    if not await limiter.strategy.test(self.item, *built_keys):\n        raise RateLimitExceeded(\n            limit=self.item, detail=f\"Rate limit exceeded: {self.item}\"\n        )\n    request.state.limit = self\n    request.state.limit_keys = built_keys\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies._InjectedLimiterDependency","title":"_InjectedLimiterDependency","text":"<p>               Bases: <code>BaseLimiterDependency</code></p> <p>A modified version of this class will be injected into the     <code>APIRoute</code> dependencies to trick FastAPI to resolve the dependencies inside of the functions passed from     filter argument of <code>limit</code> decorator.</p> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>class _InjectedLimiterDependency(BaseLimiterDependency):\n    \"\"\"\n    A modified version of this class will be injected into the\n        `APIRoute` dependencies to trick FastAPI to resolve the dependencies inside of the functions passed from\n        filter argument of `limit` decorator.\n    \"\"\"\n\n    async def __call__(\n        self,\n        request: Request,\n        response: Response,\n        keys: list[str],\n        filters: dict[str, bool],\n    ) -&gt; Any:\n        if all(filters.values()):\n            return await super(type(self), self).__call__(request, response, keys)\n\n    @classmethod\n    def apply_dependencies(\n        cls,\n        keys: StrOrCallableKey | list[StrOrCallableKey] | None,\n        filters: CallableFilter | list[CallableFilter] | None,\n    ) -&gt; Type[Self]:\n        \"\"\"Applies the filters and keys provided by the caller to a modified version of this class and returns it\n\n        Returns:\n            Type[_injectedLimiterDependency]:\n        \"\"\"\n        if not keys and not filters:\n            return cls  # do not change anything\n\n        dep_class = type(\n            cls.__name__,\n            cls.__bases__,\n            dict(cls.__dict__),\n        )\n\n        # create a copy of resovler functions and change their signature to add keys and filters as dependencies for FastAPI to pick up\n        _keys_resolver = keys_resolver\n        _filters_resolver = filters_resolver\n        keys = ensure_list(keys)\n        filters = ensure_list(filters)\n        _keys_resolver = fncopy(\n            keys_resolver,\n            sig=tuple(\n                inspect.Parameter(\n                    k.__name__, inspect.Parameter.KEYWORD_ONLY, default=Depends(k)\n                )\n                if not isinstance(k, str)\n                else inspect.Parameter(k, inspect.Parameter.KEYWORD_ONLY, default=k)\n                for k in keys\n            ),\n        )\n        _filters_resolver = fncopy(\n            filters_resolver,\n            sig=tuple(\n                inspect.Parameter(\n                    f.__name__, inspect.Parameter.KEYWORD_ONLY, default=Depends(f)\n                )\n                for f in filters\n            ),\n        )\n\n        sig = inspect.signature(dep_class.__call__)\n\n        sig_params = tuple(sig.parameters.values())[:-2] + tuple(\n            (\n                inspect.Parameter(\n                    \"keys\",\n                    inspect.Parameter.KEYWORD_ONLY,\n                    default=Depends(_keys_resolver),\n                ),\n                inspect.Parameter(\n                    \"filters\",\n                    inspect.Parameter.KEYWORD_ONLY,\n                    default=Depends(_filters_resolver),\n                ),\n            )\n        )\n        dep_class.__call__.__signature__ = sig.replace(parameters=sig_params)\n        return dep_class  # type: ignore\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies._InjectedLimiterDependency.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(\n    request: Request,\n    response: Response,\n    keys: list[str],\n    filters: dict[str, bool],\n) -&gt; Any\n</code></pre> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>async def __call__(\n    self,\n    request: Request,\n    response: Response,\n    keys: list[str],\n    filters: dict[str, bool],\n) -&gt; Any:\n    if all(filters.values()):\n        return await super(type(self), self).__call__(request, response, keys)\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies._InjectedLimiterDependency.apply_dependencies","title":"apply_dependencies  <code>classmethod</code>","text":"<pre><code>apply_dependencies(\n    keys: StrOrCallableKey | list[StrOrCallableKey] | None,\n    filters: CallableFilter | list[CallableFilter] | None,\n) -&gt; Type[Self]\n</code></pre> <p>Applies the filters and keys provided by the caller to a modified version of this class and returns it</p> <p>Returns:</p> Type Description <code>Type[Self]</code> <p>Type[_injectedLimiterDependency]:</p> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>@classmethod\ndef apply_dependencies(\n    cls,\n    keys: StrOrCallableKey | list[StrOrCallableKey] | None,\n    filters: CallableFilter | list[CallableFilter] | None,\n) -&gt; Type[Self]:\n    \"\"\"Applies the filters and keys provided by the caller to a modified version of this class and returns it\n\n    Returns:\n        Type[_injectedLimiterDependency]:\n    \"\"\"\n    if not keys and not filters:\n        return cls  # do not change anything\n\n    dep_class = type(\n        cls.__name__,\n        cls.__bases__,\n        dict(cls.__dict__),\n    )\n\n    # create a copy of resovler functions and change their signature to add keys and filters as dependencies for FastAPI to pick up\n    _keys_resolver = keys_resolver\n    _filters_resolver = filters_resolver\n    keys = ensure_list(keys)\n    filters = ensure_list(filters)\n    _keys_resolver = fncopy(\n        keys_resolver,\n        sig=tuple(\n            inspect.Parameter(\n                k.__name__, inspect.Parameter.KEYWORD_ONLY, default=Depends(k)\n            )\n            if not isinstance(k, str)\n            else inspect.Parameter(k, inspect.Parameter.KEYWORD_ONLY, default=k)\n            for k in keys\n        ),\n    )\n    _filters_resolver = fncopy(\n        filters_resolver,\n        sig=tuple(\n            inspect.Parameter(\n                f.__name__, inspect.Parameter.KEYWORD_ONLY, default=Depends(f)\n            )\n            for f in filters\n        ),\n    )\n\n    sig = inspect.signature(dep_class.__call__)\n\n    sig_params = tuple(sig.parameters.values())[:-2] + tuple(\n        (\n            inspect.Parameter(\n                \"keys\",\n                inspect.Parameter.KEYWORD_ONLY,\n                default=Depends(_keys_resolver),\n            ),\n            inspect.Parameter(\n                \"filters\",\n                inspect.Parameter.KEYWORD_ONLY,\n                default=Depends(_filters_resolver),\n            ),\n        )\n    )\n    dep_class.__call__.__signature__ = sig.replace(parameters=sig_params)\n    return dep_class  # type: ignore\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.filters_resolver","title":"filters_resolver","text":"<pre><code>filters_resolver(**filters: bool) -&gt; dict[str, bool]\n</code></pre> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>def filters_resolver(**filters: bool) -&gt; dict[str, bool]:\n    return filters\n</code></pre>"},{"location":"api-refrence/dependencies/#fastlimiter.dependencies.keys_resolver","title":"keys_resolver","text":"<pre><code>keys_resolver(**keys: str) -&gt; list[str]\n</code></pre> Source code in <code>fastlimiter/dependencies.py</code> <pre><code>def keys_resolver(**keys: str) -&gt; list[str]:\n    return list(keys.values())\n</code></pre>"},{"location":"api-refrence/exceptions/","title":"Exceptions","text":""},{"location":"api-refrence/exceptions/#fastlimiter.exceptions._default_429_response","title":"_default_429_response  <code>module-attribute</code>","text":"<pre><code>_default_429_response = {\n    \"model\": TooManyRequests,\n    \"headers\": {\n        \"retry_after\": {\n            \"description\": \"Retry after n seconds\",\n            \"type\": \"integer\",\n        }\n    },\n}\n</code></pre>"},{"location":"api-refrence/exceptions/#fastlimiter.exceptions.RateLimitExceeded","title":"RateLimitExceeded","text":"<p>               Bases: <code>HTTPException</code></p> <p>exception raised when a rate limit is hit.</p> Source code in <code>fastlimiter/exceptions.py</code> <pre><code>class RateLimitExceeded(HTTPException):\n    \"\"\"\n    exception raised when a rate limit is hit.\n    \"\"\"\n\n    limit = None\n\n    def __init__(\n        self,\n        limit: RateLimitItem,\n        status_code: int = status.HTTP_429_TOO_MANY_REQUESTS,\n        detail: str | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        self.limit = limit\n        # TODO: calculate retry_after and add it to the headers\n        super().__init__(\n            status_code=status_code,\n            detail=detail if detail else str(limit),\n            headers=headers,\n        )\n</code></pre>"},{"location":"api-refrence/exceptions/#fastlimiter.exceptions.RateLimitExceeded.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limit = limit\n</code></pre>"},{"location":"api-refrence/exceptions/#fastlimiter.exceptions.RateLimitExceeded.__init__","title":"__init__","text":"<pre><code>__init__(\n    limit: RateLimitItem,\n    status_code: int = status.HTTP_429_TOO_MANY_REQUESTS,\n    detail: str | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> Source code in <code>fastlimiter/exceptions.py</code> <pre><code>def __init__(\n    self,\n    limit: RateLimitItem,\n    status_code: int = status.HTTP_429_TOO_MANY_REQUESTS,\n    detail: str | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    self.limit = limit\n    # TODO: calculate retry_after and add it to the headers\n    super().__init__(\n        status_code=status_code,\n        detail=detail if detail else str(limit),\n        headers=headers,\n    )\n</code></pre>"},{"location":"api-refrence/exceptions/#fastlimiter.exceptions.TooManyRequests","title":"TooManyRequests","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>fastlimiter/exceptions.py</code> <pre><code>class TooManyRequests(BaseModel):\n    detail: str = \"Rate limit exceeded: {x} per {y} {granularity}\"\n</code></pre>"},{"location":"api-refrence/exceptions/#fastlimiter.exceptions.TooManyRequests.detail","title":"detail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>detail: str = (\n    \"Rate limit exceeded: {x} per {y} {granularity}\"\n)\n</code></pre>"},{"location":"api-refrence/functions/","title":"Functions","text":""},{"location":"api-refrence/functions/#fastlimiter.functions.get_remote_address","title":"get_remote_address","text":"<pre><code>get_remote_address(request: Request) -&gt; str\n</code></pre> <p>Utility function to use remote address as a limit key</p> Source code in <code>fastlimiter/functions.py</code> <pre><code>def get_remote_address(request: Request) -&gt; str:\n    \"\"\"Utility function to use remote address as a limit key\"\"\"\n    if not request.client or not request.client.host:\n        return \"127.0.0.1\"\n    return request.client.host\n</code></pre>"},{"location":"api-refrence/functions/#fastlimiter.functions.get_path","title":"get_path","text":"<pre><code>get_path(request: Request) -&gt; str\n</code></pre> <p>Utility function to use path as a limit key</p> Source code in <code>fastlimiter/functions.py</code> <pre><code>def get_path(request: Request) -&gt; str:\n    \"\"\"Utility function to use path as a limit key\"\"\"\n    return request.url.path\n</code></pre>"},{"location":"api-refrence/limiter/","title":"Limiter","text":""},{"location":"api-refrence/limiter/#fastlimiter.limiter.limit","title":"limit","text":"<pre><code>limit(\n    router: SupportsRoutes,\n    limit_string: str,\n    keys: (\n        StrOrCallableKey | list[StrOrCallableKey] | None\n    ) = None,\n    filters: (\n        CallableFilter | list[CallableFilter] | None\n    ) = None,\n    no_hit_status_codes: list[int] | None = None,\n    default_response_model: (\n        dict[str, Any] | None\n    ) = _default_429_response,\n    show_limit_in_response_model: bool = True,\n    override_default_keys: bool = False,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>A decorator function to apply limits to any route definition or group of routes.</p> Note <p>You can use this function both as a decorator to apply limit to a route:</p> <pre><code>@limit(app, \"5/minute\")\n@app.get(\"/\")\ndef show_items(...):\n    ...\n</code></pre> <p>Or otherwise you can apply limits to a group of routes in a <code>APIRouter</code> object or <code>FastAPI</code> object:</p> <pre><code>router = APIRouter(prefix=\"/items\")\n\n@router.get(\"/\")\ndef get_items(...):\n    ...\n\n\n@router.post(\"/\")\ndef create_item(...):\n    ...\n\n\nlimit(router, \"5/minute\")\n</code></pre> <p>In the second example the \"5 per minute\" limit will be applied to both <code>get_items</code> and <code>create_item</code> routes.</p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>SupportsRoutes</code> <p>An object that has <code>routes</code> attribute available with <code>router.routes</code> which ther routes are <code>APIRoute</code> objects. for example: <code>APIRouter</code> or <code>FastAPI</code> instances.</p> required <code>limit_string</code> <code>str</code> <p>limit string in the format of {x}/{granularity}. for example: \"5/minute\" or \"1/hour\"</p> required <code>keys</code> <code>CallableKey | list[CallableKey] | None</code> <p>the unique keys to be used for this route. you can apply limits to routes using a shared key, all these routes limits will be calculated together. for example if you use the same keys for 'POST /items' and 'GET /items', rate limit will hit on that key with calling any of them.</p> <code>None</code> <code>filters</code> <code>CallableFilter | list[CallableFilter] | None</code> <p>Filters to check before counting a hit. It has to be a function or async function that returns a bool. a hit will be count if all of the filters return True. you can use Depends for filters and they will be resolved by FastAPI automatically.</p> <code>None</code> <code>no_hit_status_codes</code> <code>list[int] | None</code> <p>a list of status codes to not count a hit when they are returned. for example if you pass <code>[400, 404]</code>, if the response status code was in the list, a hit will not be counted.</p> <code>None</code> <code>default_response_model</code> <code>dict[str, Any] | None</code> <p>default response model to use for 429 responses in the autogenerated docs. if <code>None</code> was passed, nothing will be shown in the docs about this response.</p> <code>_default_429_response</code> <code>show_limit_in_response_model</code> <code>bool</code> <p>Should the values for rate-limit be shown in the response model?</p> <code>True</code> <code>override_default_keys</code> <code>bool</code> <p>provided 'keys' should be added to default keys or override default keys</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Callable[[Callable[P, R]], Callable[P, R]] | None</p> Note <p>This function returns a <code>Callable</code> if it was used as a decorator ('@' syntax) otherwise <code>None</code>.</p> Source code in <code>fastlimiter/limiter.py</code> <pre><code>def limit(\n    router: SupportsRoutes,\n    limit_string: str,\n    keys: StrOrCallableKey | list[StrOrCallableKey] | None = None,\n    filters: CallableFilter | list[CallableFilter] | None = None,\n    no_hit_status_codes: list[int] | None = None,\n    default_response_model: dict[str, Any] | None = _default_429_response,\n    show_limit_in_response_model: bool = True,\n    override_default_keys: bool = False,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"A decorator function to apply limits to any route definition or group of routes.\n\n    Note:\n        You can use this function both as a decorator to apply limit to a route:\n\n        ```py\n        @limit(app, \"5/minute\")\n        @app.get(\"/\")\n        def show_items(...):\n            ...\n        ```\n\n        Or otherwise you can apply limits to a group of routes in a `APIRouter` object or `FastAPI` object:\n\n        ```py\n        router = APIRouter(prefix=\"/items\")\n\n        @router.get(\"/\")\n        def get_items(...):\n            ...\n\n\n        @router.post(\"/\")\n        def create_item(...):\n            ...\n\n\n        limit(router, \"5/minute\")\n        ```\n\n        In the second example the \"5 per minute\" limit will be applied to both `get_items` and `create_item` routes.\n\n    Args:\n        router (SupportsRoutes): An object that has `routes` attribute available with `router.routes` which ther routes are `APIRoute` objects. for example: `APIRouter` or `FastAPI` instances.\n        limit_string (str): limit string in the format of {x}/{granularity}. for example: \"5/minute\" or \"1/hour\"\n        keys (CallableKey | list[CallableKey] | None, optional): the unique keys to be used for this route. you can apply limits to routes using a shared key, all these routes limits will be calculated together. for example if you use the same keys for 'POST /items' and 'GET /items', rate limit will hit on that key with calling any of them.\n        filters (CallableFilter | list[CallableFilter] | None, optional): Filters to check before counting a hit. It has to be a function or async function that returns a bool. a hit will be count if all of the filters return True. you can use Depends for filters and they will be resolved by FastAPI automatically.\n        no_hit_status_codes (list[int] | None, optional): a list of status codes to not count a hit when they are returned. for example if you pass `[400, 404]`, if the response status code was in the list, a hit will not be counted.\n        default_response_model (dict[str, Any] | None, optional): default response model to use for 429 responses in the autogenerated docs. if `None` was passed, nothing will be shown in the docs about this response.\n        show_limit_in_response_model (bool, optional): Should the values for rate-limit be shown in the response model?\n        override_default_keys (bool, optional): provided 'keys' should be added to default keys or override default keys\n\n    Returns:\n        Callable[[Callable[P, R]], Callable[P, R]] | None\n\n    Note:\n        This function returns a `Callable` if it was used as a decorator ('@' syntax) otherwise `None`.\n\n    \"\"\"\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        route = find_api_route(router, func)\n        if route:\n            apply_limit(\n                route=route,\n                item=parse(limit_string),\n                keys=keys,\n                filters=filters,\n                no_hit_status_codes=no_hit_status_codes,\n                default_response_model=default_response_model,\n                show_limit_in_response_model=show_limit_in_response_model,\n                override_default_keys=override_default_keys,\n            )\n        return func\n\n    # check to see if this function was used as a decorator or not\n    if ctx := inspect.stack()[1].code_context:\n        if not ctx[0].strip().startswith(\"@\"):\n            item = parse(limit_string)\n            for route in get_api_routes(router):\n                apply_limit(\n                    route=route,\n                    item=item,\n                    keys=keys,\n                    filters=filters,\n                    no_hit_status_codes=no_hit_status_codes,\n                    default_response_model=default_response_model,\n                    show_limit_in_response_model=show_limit_in_response_model,\n                    override_default_keys=override_default_keys,\n                )\n            return  # type: ignore\n    return decorator\n</code></pre>"},{"location":"api-refrence/limiter/#fastlimiter.limiter.apply_limit","title":"apply_limit","text":"<pre><code>apply_limit(\n    route: APIRoute,\n    item: RateLimitItem,\n    keys: StrOrCallableKey | list[StrOrCallableKey] | None,\n    filters: CallableFilter | list[CallableFilter] | None,\n    no_hit_status_codes: list[int] | None,\n    default_response_model: dict[str, Any] | None,\n    show_limit_in_response_model: bool,\n    override_default_keys: bool,\n) -&gt; None\n</code></pre> <p>Apply the limit to an <code>APIRoute</code> object</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>APIRoute</code> <p>route to apply the limit to</p> required <code>item</code> <code>RateLimitItem</code> <p>rate limit value</p> required <code>keys</code> <code>CallableKey | list[CallableKey] | None</code> <p>a list of keys that identify a route or group of routes</p> required <code>filters</code> <code>CallableFilter | list[CallableFilter] | None</code> <p>filters to check before hitting on a limit</p> required <code>no_hit_status_codes</code> <code>list[int] | None</code> <p>response status codes that should not be count as a hit</p> required <code>default_response_model</code> <code>dict[str, Any] | None</code> <p>default response model schema to show in docs</p> required <code>show_limit_in_response_model</code> <code>bool</code> <p>should the value of rate limit be shown on the docs or not</p> required <code>override_default_keys</code> <code>bool</code> <p>wether to override default keys or extend them</p> required Source code in <code>fastlimiter/limiter.py</code> <pre><code>def apply_limit(\n    route: APIRoute,\n    item: RateLimitItem,\n    keys: StrOrCallableKey | list[StrOrCallableKey] | None,\n    filters: CallableFilter | list[CallableFilter] | None,\n    no_hit_status_codes: list[int] | None,\n    default_response_model: dict[str, Any] | None,\n    show_limit_in_response_model: bool,\n    override_default_keys: bool,\n) -&gt; None:\n    \"\"\"Apply the limit to an `APIRoute` object\n\n    Args:\n        route (APIRoute): route to apply the limit to\n        item (RateLimitItem): rate limit value\n        keys (CallableKey | list[CallableKey] | None): a list of keys that identify a route or group of routes\n        filters (CallableFilter | list[CallableFilter] | None): filters to check before hitting on a limit\n        no_hit_status_codes (list[int] | None): response status codes that should not be count as a hit\n        default_response_model (dict[str, Any] | None): default response model schema to show in docs\n        show_limit_in_response_model (bool): should the value of rate limit be shown on the docs or not\n        override_default_keys (bool): wether to override default keys or extend them\n\n    \"\"\"\n    if default_response_model is not None:\n        route.responses[429] = default_response_model\n        if (model := route.responses[429].get(\"model\", None)) is not None:\n            route.response_fields[429] = create_model_field(\n                name=f\"Response_429_{route.unique_id}\",\n                type_=create_response_model(model, item, show_limit_in_response_model),\n            )\n    keys = ensure_list(keys)\n    if override_default_keys:\n        if not keys:\n            raise ValueError(\"Can't override default keys when no key is supplied\")\n    else:\n        keys.insert(\n            0, route.endpoint.__name__\n        )  # add endpoint's funtion name as the first element of the key by default\n\n    # TODO: check if other limits were added previously\n    dep_class = BaseLimiterDependency\n    if filters or keys:\n        dep_class = _InjectedLimiterDependency.apply_dependencies(keys, filters)\n    limit_dependency = Depends(\n        dep_class(\n            limit_value=item,\n            no_hit_status_codes=no_hit_status_codes,\n        )\n    )\n    route.dependant.dependencies.insert(\n        0,\n        get_parameterless_sub_dependant(\n            depends=limit_dependency,\n            path=route.path_format,\n        ),\n    )\n</code></pre>"},{"location":"api-refrence/middleware/","title":"Middleware","text":""},{"location":"api-refrence/middleware/#fastlimiter.middleware.RateLimitingMiddleware","title":"RateLimitingMiddleware","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> Source code in <code>fastlimiter/middleware.py</code> <pre><code>class RateLimitingMiddleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app: ASGIApp,\n        strategy: RateLimiter,\n        keys: CallableMiddlewareKey | list[CallableMiddlewareKey] | None = None,\n    ) -&gt; None:\n        self.strategy = strategy\n        self.keys: list[CallableMiddlewareKey] = (\n            ensure_list(keys) if keys else ensure_list(get_remote_address)\n        )\n        super().__init__(app)\n\n    async def dispatch(\n        self, request: Request, call_next: Callable[[Request], Awaitable[Response]]\n    ) -&gt; Response:\n        # just add the limit middleware to the request.state, the dependency on the 'APIRoute' takes care of the rest\n        request.state.limiter = self\n        response = await call_next(request)\n        try:\n            limit: \"BaseLimiterDependency\" = request.state.limit\n            limit_keys: list[str] = request.state.limit_keys\n        except AttributeError:\n            return response\n        if (\n            limit.no_hit_status_codes\n            and response.status_code in limit.no_hit_status_codes\n        ):\n            return response\n\n        await self.strategy.hit(\n            limit.item,\n            *limit_keys,\n        )\n        return response\n</code></pre>"},{"location":"api-refrence/middleware/#fastlimiter.middleware.RateLimitingMiddleware.strategy","title":"strategy  <code>instance-attribute</code>","text":"<pre><code>strategy = strategy\n</code></pre>"},{"location":"api-refrence/middleware/#fastlimiter.middleware.RateLimitingMiddleware.keys","title":"keys  <code>instance-attribute</code>","text":"<pre><code>keys: list[CallableMiddlewareKey] = (\n    ensure_list(keys)\n    if keys\n    else ensure_list(get_remote_address)\n)\n</code></pre>"},{"location":"api-refrence/middleware/#fastlimiter.middleware.RateLimitingMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    app: ASGIApp,\n    strategy: RateLimiter,\n    keys: (\n        CallableMiddlewareKey\n        | list[CallableMiddlewareKey]\n        | None\n    ) = None,\n) -&gt; None\n</code></pre> Source code in <code>fastlimiter/middleware.py</code> <pre><code>def __init__(\n    self,\n    app: ASGIApp,\n    strategy: RateLimiter,\n    keys: CallableMiddlewareKey | list[CallableMiddlewareKey] | None = None,\n) -&gt; None:\n    self.strategy = strategy\n    self.keys: list[CallableMiddlewareKey] = (\n        ensure_list(keys) if keys else ensure_list(get_remote_address)\n    )\n    super().__init__(app)\n</code></pre>"},{"location":"api-refrence/middleware/#fastlimiter.middleware.RateLimitingMiddleware.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(\n    request: Request,\n    call_next: Callable[[Request], Awaitable[Response]],\n) -&gt; Response\n</code></pre> Source code in <code>fastlimiter/middleware.py</code> <pre><code>async def dispatch(\n    self, request: Request, call_next: Callable[[Request], Awaitable[Response]]\n) -&gt; Response:\n    # just add the limit middleware to the request.state, the dependency on the 'APIRoute' takes care of the rest\n    request.state.limiter = self\n    response = await call_next(request)\n    try:\n        limit: \"BaseLimiterDependency\" = request.state.limit\n        limit_keys: list[str] = request.state.limit_keys\n    except AttributeError:\n        return response\n    if (\n        limit.no_hit_status_codes\n        and response.status_code in limit.no_hit_status_codes\n    ):\n        return response\n\n    await self.strategy.hit(\n        limit.item,\n        *limit_keys,\n    )\n    return response\n</code></pre>"},{"location":"api-refrence/types/","title":"Types","text":""},{"location":"api-refrence/types/#fastlimiter.types.SupportsRoutes","title":"SupportsRoutes  <code>module-attribute</code>","text":"<pre><code>SupportsRoutes: TypeAlias = APIRouter | FastAPI\n</code></pre>"},{"location":"api-refrence/types/#fastlimiter.types.ModelT","title":"ModelT  <code>module-attribute</code>","text":"<pre><code>ModelT = TypeVar('ModelT', bound=BaseModel)\n</code></pre>"},{"location":"api-refrence/types/#fastlimiter.types.CallableMiddlewareKey","title":"CallableMiddlewareKey  <code>module-attribute</code>","text":"<pre><code>CallableMiddlewareKey: TypeAlias = Callable[\n    [Request], str | Awaitable[str]\n]\n</code></pre>"},{"location":"api-refrence/types/#fastlimiter.types.StrOrCallableKey","title":"StrOrCallableKey  <code>module-attribute</code>","text":"<pre><code>StrOrCallableKey: TypeAlias = (\n    str | Callable[..., str | Awaitable[str]]\n)\n</code></pre>"},{"location":"api-refrence/types/#fastlimiter.types.CallableFilter","title":"CallableFilter  <code>module-attribute</code>","text":"<pre><code>CallableFilter: TypeAlias = Callable[\n    ..., bool | Awaitable[bool]\n]\n</code></pre>"},{"location":"api-refrence/utils/","title":"Utils","text":""},{"location":"api-refrence/utils/#fastlimiter.utils.get_api_routes","title":"get_api_routes","text":"<pre><code>get_api_routes(\n    router: SupportsRoutes,\n) -&gt; Generator[APIRoute, None, None]\n</code></pre> <p>Generator that yields <code>APIRoute</code> objects from an <code>APIRouter</code></p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>SupportsRoutes</code> <p>router object, can be <code>APIRouter</code> or <code>FastAPI</code></p> required <p>Yields:</p> Type Description <code>APIRoute</code> <p>Generator[APIRoute, None, None]: the <code>APIRoute</code> object</p> Source code in <code>fastlimiter/utils.py</code> <pre><code>def get_api_routes(router: SupportsRoutes) -&gt; Generator[APIRoute, None, None]:\n    \"\"\"Generator that yields `APIRoute` objects from an `APIRouter`\n\n    Args:\n        router (SupportsRoutes): router object, can be `APIRouter` or `FastAPI`\n\n    Yields:\n        Generator[APIRoute, None, None]: the `APIRoute` object\n    \"\"\"\n    yield from (r for r in router.routes if isinstance(r, APIRoute))\n</code></pre>"},{"location":"api-refrence/utils/#fastlimiter.utils.find_api_route","title":"find_api_route","text":"<pre><code>find_api_route(\n    router: SupportsRoutes, func: Callable[..., Any]\n) -&gt; APIRoute | None\n</code></pre> <p>Find the APIRoute object from the APIRouter.routes or FastAPI.routes</p> Source code in <code>fastlimiter/utils.py</code> <pre><code>def find_api_route(router: SupportsRoutes, func: Callable[..., Any]) -&gt; APIRoute | None:\n    \"\"\"Find the APIRoute object from the APIRouter.routes or FastAPI.routes\"\"\"\n    for r in get_api_routes(router):\n        if getattr(r, \"endpoint\", None) == func:\n            return r\n</code></pre>"},{"location":"api-refrence/utils/#fastlimiter.utils.create_response_model","title":"create_response_model","text":"<pre><code>create_response_model(\n    model: type[ModelT],\n    parsed_limit: RateLimitItem,\n    show_limit_in_response_model: bool = False,\n) -&gt; type[ModelT]\n</code></pre> <p>Returns a copy of the model with the default value updated and placeholders filled.G</p> Source code in <code>fastlimiter/utils.py</code> <pre><code>def create_response_model(\n    model: type[ModelT],\n    parsed_limit: RateLimitItem,\n    show_limit_in_response_model: bool = False,\n) -&gt; type[ModelT]:\n    \"\"\"\n    Returns a copy of the model with the default value updated and placeholders filled.G\n    \"\"\"\n    _model = model\n    if show_limit_in_response_model:\n        if (detail := model.model_fields.get(\"detail\", None)) is not None:\n            _detail = detail.default.format(\n                x=parsed_limit.amount,\n                y=parsed_limit.multiples,\n                granularity=parsed_limit.GRANULARITY.name,\n            )\n            _model = create_model(\n                model.__name__,\n                __base__=model,\n                detail=(str, _detail),\n            )\n    return _model\n</code></pre>"},{"location":"api-refrence/utils/#fastlimiter.utils.fncopy","title":"fncopy","text":"<pre><code>fncopy(\n    func: Callable[..., R], sig: tuple[Parameter, ...]\n) -&gt; Callable[..., R]\n</code></pre> <p>creates a deepcopy of a function with the same code, globals, defaults, closures but slighlty different signature</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>the function to create a copy of</p> required <code>sig</code> <code>tuple[Parameter]</code> <p>new parameters</p> required <p>Returns:</p> Type Description <code>Callable[..., R]</code> <p>Callable[P, R]: the copied new function</p> Source code in <code>fastlimiter/utils.py</code> <pre><code>def fncopy(\n    func: Callable[..., R], sig: tuple[inspect.Parameter, ...]\n) -&gt; Callable[..., R]:\n    \"\"\"creates a deepcopy of a function with the same code, globals, defaults, closures but slighlty different signature\n\n    Args:\n        func (Callable[P, R]): the function to create a copy of\n        sig (tuple[inspect.Parameter]): new parameters\n\n    Returns:\n        Callable[P, R]: the copied new function\n    \"\"\"\n    fn = types.FunctionType(\n        func.__code__,\n        func.__globals__,\n        func.__name__,\n        func.__defaults__,\n        func.__closure__,\n    )\n    fn.__dict__.update(func.__dict__)\n    fn.__signature__ = inspect.Signature(parameters=sig)  # type: ignore\n    return fn\n</code></pre>"},{"location":"api-refrence/utils/#fastlimiter.utils.ensure_list","title":"ensure_list","text":"<pre><code>ensure_list(value: P | list[P] | None) -&gt; list[P]\n</code></pre> <p>ensure the value is a list</p> <p>returns an empty list if value is None</p> Source code in <code>fastlimiter/utils.py</code> <pre><code>def ensure_list(value: P | list[P] | None) -&gt; list[P]:\n    \"\"\"ensure the value is a list\n\n    returns an empty list if value is None\n    \"\"\"\n    if not value:\n        return []\n    if isinstance(value, list):\n        return value\n    return [value]\n</code></pre>"},{"location":"user-guide/filters/","title":"Filters","text":"<p>Filters are nice addition to keys. but they are different from each other and do completly different things.</p> <p>as we said before, Keys are what distinguish each endpoint, or each user from each other.</p> <p>a combination of Keys will create a <code>limit item</code> and that limit item is what we check for rate limiting.</p> <p>Filters on the other hand, are conditions that we check to see if we should count a <code>Hit</code> or not.</p> <p>let's explain with a simple example:</p> <p>we have two user levels: admins and normal users.</p> <pre><code># first lets define our roles\nclass Role(enum.Enum):\n    admin = \"admin\"\n    user = \"user\"\n\n# and we create a user class for the sake of this example\nclass User(BaseModel):\n    username: str\n    email: str\n\n    role: Role\n</code></pre> <p>what if we want to define different kind of limits for each role. for example 10 request per minute for normal users, but no limits for admin users.</p> <p>this is where filters come handy.</p> <p>we can create a filter that checks and finds normal users before we apply limits:</p> <pre><code>def filter_not_admin(user: User = Depends(get_current_user)) -&gt; bool:\n    return user.role != Role.admin\n</code></pre> <p>and thats it! now we can use this filter in our endpoints:</p> <pre><code>@limit(app, \"10/minute\", filters=filter_not_admin)\n@app.get(\"/\")\nasync def get_some_resource(user: User = Depends(get_current_user)):\n    ...\n</code></pre> <p>and done! neat right?</p> <p>now if a normal user calls this endpoint more than 10 times per minute, they will be banned. but an admin user can call as much as they want.</p> <p>you can even define seperate limits for this two roles:</p> <pre><code>@limit(app, \"10/minute\", filters=filter_not_admin)\n@limit(app, \"100/minute\")\n@app.get(\"/\")\nasync def get_some_resource(user: User = Depends(get_current_user)):\n    ...\n</code></pre> <p>The limits are processed top to bottom, so if the filters of first limit will satisfy (user is not an admin), the second one would not be processed.</p> <p>and the opposite of this works too. if the first limit's filters would not return <code>True</code> (the user is an admin), the second one would be hit.</p> <p>Warning</p> <p>be careful when combining multiple limits together, they might cause unwanted outcomes if you don't order them properly!</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":"<p>There are a couple of things you should know before we get started.</p> <p>There are only few concepts that you should know about. Hit, Filters and Keys.</p>"},{"location":"user-guide/getting-started/#hit","title":"Hit","text":"<p>Each time a request comes in, some conditions will be checked and if those conditions were met, a <code>hit</code> will be count for that limit item.</p> <p>take a look at this simple example:</p> <pre><code>@limit(app, \"5/minute\")\n@app.get(\"/\")\nasync def items(...):\n    ...\n</code></pre> <p>for this very simple example, the only condition that applies is the <code>path</code> (<code>\"/\"</code>) and the provided keys to the middleware that distinguish each user.</p> <p>by default each user will be identified by their ip addresses.</p> <p>so the key for this request will be something like:</p> <pre><code>[\"127.0.0.1\", \"/\", \"items\"]\n</code></pre> <p>we call this combination of strings, a <code>limit item</code>.</p> <p>everytime we encounter a key like this, we will count a <code>Hit</code> for that limit item.</p> <p>Note</p> <p>we go into more details about keys later at Keys.</p> <p>and in this context, if the user sends more than 5 requests to that key in less than a minute, they will get a '429 TOO Many Requests' response.</p> <p>It gets a little more complex than this in the real world. what if we want to apply limits based on users roles?</p> <p>take this, we want <code>'admin'</code> users to be able to call the <code>\"/\"</code> endpoint 100 times per minute, but <code>'normal'</code> users could only do 10 per minute.</p> <p>this is where Filters come in.</p>"},{"location":"user-guide/getting-started/#filters","title":"Filters","text":"<p>What are filters? as the name suggest, they filter out requests based on provided data  and if all the filters say 'True', the limit item will be applied and a <code>Hit</code> will be calculated.</p> <p>filters can be any callable, they can be async or sync, they can even contain a dependency. but they must return a <code>bool</code>.</p> <p>here's a simple example:</p> <pre><code>def filter_not_admins(user: User = Depends(get_current_user)) -&gt; bool:\n    if user.role != \"admin\":\n        return True\n    return False\n</code></pre> <p>now we have a filter and we can use it in our limit item:</p> <pre><code>@limit(app, \"5/minute\", filters=filter_not_admins)\n@app.get(\"/\")\nasync def items(user: User = Depends(get_current_user)):\n    ...\n</code></pre> <p>and thats it! now our limit only works when the user is not an <code>admin</code>. </p> <p>Note</p> <p>Do not worry about the use of <code>get_current_user</code> if you used it multiple times like our example here, <code>FastAPI</code> will cache dependencies and <code>get_current_user</code> will be called only once!</p> <p>More about filters</p> <p>You can learn more about Filters here</p> <p>now we can go one step forward and add more conditions to our limits, group our limits together and much more.</p>"},{"location":"user-guide/getting-started/#keys","title":"Keys","text":"<p>Keys are essentially the thing that make a <code>limit item</code> distinguishable from others. lets take another look at our example from before:</p> <pre><code>@limit(app, \"5/minute\")\n@app.get(\"/\")\nasync def get_items(...):\n    ...\n\n\n@limit(app, \"5/minute\")\n@app.post(\"/\")\nasync def create_items(...):\n    ...\n</code></pre> <p>lets say we want to limit this two endpoints together, any hit on <code>get_items</code> will be the same as a hit on <code>create_items</code>.</p> <p>what i mean by this is that if the user calls the <code>get_items</code> 3 times, and <code>create_items</code> 2 times, we have 5 in total and the user should be limited.</p> <p>by default the keys for this two endpoints are different. for example:</p> <p>get_items:</p> <pre><code>[\"127.0.0.1\", \"/\", \"get_items\"]\n</code></pre> <p>create_items: <pre><code>[\"127.0.0.1\", \"/\", \"create_items\"]\n</code></pre></p> <p>and as we said before, these are two different keys and are calculated seperately. </p> <p>but we can get around this by using the <code>keys=</code> argument from the <code>limit</code>!</p> <pre><code>@limit(app, \"5/minute\", keys=\"items\")\n@app.get(\"/\")\nasync def get_items(...):\n    ...\n\n\n@limit(app, \"5/minute\", keys=\"items\")\n@app.post(\"/\")\nasync def create_items(...):\n    ...\n</code></pre> <p>so now the keys to both of this endpoints will be <code>[\"127.0.0.1\", \"/\", \"items\"]</code> and they will be treaded as they are the same endpoint!</p> <p>Warning</p> <p>be carefull when doing this! the limit on both of this endpoints must match, for example here both are <code>\"5/minute\"</code>, the library does not constraint you from doing otherwise but unwanted conditions might occur!</p> <p>More about keys</p> <p>You can learn more about Keys here</p> <p>You can do almost anything by combining Keys and Filters together. you can learn more about these in their respective chapters.</p>"},{"location":"user-guide/install/","title":"Installation","text":"<p>You can install this library just by running:</p> <p><code>pip install fastlimiter</code></p> <p>Then you can start using it! </p> <p>As we mentioned before, FastLimiter supports multiple storage backends courtesy of limist library.</p> <p>You can read more about different flavours of limits storage backend in their Installation manual.</p> <p>But... you can take a shortcut and install those flavours directly:</p> Async RedisAsync MemcachedAsync MongodbAsync Etcd <p><code>pip install \"fastlimiter[async-redis]\"</code></p> <p><code>pip install \"fastlimiter[async-memcached]\"</code></p> <p><code>pip install \"fastlimiter[async-mongodb]\"</code></p> <p><code>pip install \"fastlimiter[async-etcd]\"</code></p> <p>Before you dive in, take a look at the next few chapters as they walk you in on how to get started.</p>"},{"location":"user-guide/keys/","title":"Keys","text":"<p>We have two knids of keys: </p> <ul> <li> <p>Middleware level keys      these keys will be applied to all of the endpoints (<code>Route</code>) or better say <code>limit items</code></p> </li> <li> <p>Endpoint level keys      thse keys are specific for each endpoint or <code>limit item</code></p> </li> </ul>"},{"location":"user-guide/keys/#middlewarew-level-keys","title":"Middlewarew level keys","text":"<p>If we take a look at our (previous examples)[../getting-started/#keys], we notice that both of our routes has some keys in common:</p> <p>take a look at <code>[\"127.0.0.1\", \"/\", \"get_items\"]</code> and <code>[\"127.0.0.1\", \"/\", \"create_items\"]</code>, the first two parts are the same. these are <code>Middleware</code> level keys.</p> <p>we use <code>Middleware</code> level keys to distinguish each user from others.</p> <p>for example we use the user's ip address here (<code>\"127.0.0.1\"</code>) as the first part of our keys. </p> <p>i sould note that there is no constraint here and you can use almost anything in the key functions. we used the <code>path</code> (<code>\"/\"</code>) for the second part here.</p> <p>we can define middleware level keys when we setup our middleware, there are some pre-defined keys in the Functions but you can create your own functions as well and use them.</p> <p>so lets create our own key function and use that in our middleware.</p> <p>the only thing that matters when creating a custom key function is that it must get only one argument, and that argument is the <code>Request</code> object passed to it from the middleware. you can use any sync or async function based on your context.</p> <p>all key fucntions must return a string, that string will be used as a key.</p> <pre><code>def get_remote_port(request: Request) -&gt; str:\n    return request.client.port\n</code></pre> <p>and thats it! we now have a key function that distinguishes different users by their <code>ip address</code>!</p> <p>now, if we want to use our key function, is as simple as this:</p> <pre><code>from fastapi import FastAPI\n\nfrom limits.aio.storage import MemoryStorage\nfrom limits.aio.strategies import FixedWindowRateLimiter\n\nfrom fastlimiter import RateLimitingMiddleware\n\n\napp = FastAPI()\n\nlimiter = FixedWindowRateLimiter(storage=MemoryStorage())\n\napp.add_middleware(\n    RateLimitingMiddleware,\n    limiter=limiter,\n    keys=[get_remote_port] # just add the key function you want to this list, be careful not to add paranthesis at the end of function names\n)\n</code></pre> <p>now if we check our limit item keys, instead of ip address from before, we get something like this:</p> <p><code>[\"55561\", \"get_items\"]</code> or <code>[\"43541\", \"create_items\"]</code> where <code>\"55561\"</code> and <code>\"43541\"</code> are different ports that requests came from.</p> <p>this is dumb, right? usgin the port here is not useful at all, but lets see another example.</p> <p>did you notice the ip from before was <code>127.0.0.1</code> and not a real ip address?</p> <p>sometimes when our application is behind a reverse proxy, a cdn or something like that, we do not see the real ip of the user,       but sometimes when they forward the requests, they include the real ip of the user in a header.</p> <p>guess what? we can use that header value as key!</p> <pre><code>def get_real_ip(request: Request) -&gt; str:\n    return request.headers.get(\"X-Real-IP\", None) or get_remote_address(request)\n</code></pre> <p>in this key function, we check for <code>X-Real-IP</code> header, if that does not exist, we fallback to the default <code>get_remote_address</code> function.</p> <p>Default key functions</p> <p>by default the function applied is get_remote_address.</p> <p>Warning</p> <p>if you use <code>keys=</code> on the middleware, the functions you provided will be overridden to the default ones, so be careful when doing this.</p>"},{"location":"user-guide/keys/#endpoint-level-keys","title":"Endpoint level keys","text":"<p>If you notice, the second part in our limit items from previous example did not change when we updated our keys. and we still have <code>\"get_items\"</code> and <code>\"create_items\"</code> in our limit keys.</p> <p>well that is because those are endpoint level keys. and by default the endpoint's function name will be used as a key for each item.</p> <p>for example if we have an endpoint defined like this:</p> <pre><code>@app.get(\"/\")\nasync def get_items(...):\n    ...\n</code></pre> <p>the <code>get_items</code> that is our function name will be used as a key by default.</p> <p>well we also have the option to override these keys as well.</p> <p>we do that by providing our key function to the <code>limit</code> decorator.</p>"},{"location":"user-guide/keys/#key-functions","title":"Key functions","text":"<p>key functions are, deep down, <code>dependencies</code>, so you can use <code>Depends</code> in them!</p> <p>we can write an endpoint level key function like this:</p> <pre><code>def get_user_id(user: User = Depends(get_current_user)) -&gt; str:\n    return str(user.id)\n\n\n@limit(app, \"5/minute\", keys=[get_user_id], override_default_keys=True)\n@app.get(\"/\")\nasync def get_items(...):\n    ...\n</code></pre> <p>now let's take a look at our limit key:</p> <p><code>[\"127.0.0.1\", \"1\"]</code></p> <p>the <code>override_default_keys</code> argument will remove default endpoint level keys and add only our provided keys to the limit item.</p> <p>if we was to pass False, for example <code>override_default_keys=False</code>, our limit key would be <code>[\"127.0.0.1\", \"get_items\", \"1\"]</code>.</p>"},{"location":"user-guide/keys/#key-strings","title":"Key strings","text":"<p>just like how we provided key functions to our limit decorator, we can use strings for the keys. </p> <pre><code>@limit(app, \"5/minute\", keys=[\"some_string\"], override_default_keys=True)\n@app.get(\"/\")\nasync def get_items(...):\n    ...\n</code></pre> <p>and now if we check our our limit key, it will be something like <code>[\"127.0.0.1\", \"some_string\"]</code>.</p> <p>where is this useful? well one useful usage of this will be when you want to create limit two or more endpoints together.</p> <pre><code>@limit(app, \"5/minute\", keys=[\"some_string\"], override_default_keys=True)\n@app.get(\"/\")\nasync def get_items(...):\n    ...\n\n@limit(app, \"5/minute\", keys=[\"some_string\"], override_default_keys=True)\n@app.post(\"/\")\nasync def create_items(...):\n    ...\n</code></pre> <p>now we bound these two endpoints together. if the user calls the first endpoint, 2 times, and second one 3 times, we have 5 in total and our limit would be filled and they can't use any of these two endpoints anymore.</p>"},{"location":"user-guide/keys/#key-functions-key-strings","title":"Key functions + Key strings","text":"<p>You also have the option to combine strings and functions together to create more specialized limit keys.</p> <pre><code>@limit(app, \"5/minute\", keys=[some_key_function, \"some_key_string\"])\n</code></pre> <p>The order matters</p> <p>be careful when adding multiple keys because the order of keys matter!</p> <p><code>[\"127.0.0.1\", \"first\", \"second\"]</code> and <code>[\"127.0.0.1\", \"second\", \"first\"]</code> are two completly different items.</p>"},{"location":"user-guide/middlewares/","title":"Middlewares","text":"<p>The thing that will be put between our application and limiting logic is our <code>Middleware</code>.</p> <p>our limiting logic won't work without this piece and has no way to intercept incoming requests.</p> <p>FastAPI Middlewares</p> <p>you can read more about middlewares in FastAPI's documentation from here.</p> <p>First of all, we have to setup our middleware, we also need some stuff from our backend library limits. we will go into more details about these later.</p> <pre><code>from fastapi import FastAPI\n\nfrom limits.aio.storage import MemoryStorage\nfrom limits.aio.strategies import FixedWindowRateLimiter\n\nfrom fastlimiter import RateLimitingMiddleware\n\n\n# create our fastapi app\n\napp = FastAPI()\n\n# create our limiter object\n\nlimiter = FixedWindowRateLimiter(storage=MemoryStorage())\n\n# add our middleware to our fastapi app\n\napp.add_middleware(\n    RateLimitingMiddleware,\n    strategy=limiter,\n)\n</code></pre> <p>And thats it! our setup is Done, now we can start adding limits to our endpoints.</p> <p>but first, let's breakdown some parts and explain a little more.</p> <p>The <code>limits</code> library supports multiple storage and strategies to use, we used the simples storage that is <code>MemoryStorage</code> and does not need anything to be installed and works out of the box.</p> <p>for the strategy, we used <code>FixedWindowRateLimiter</code> that has the least overhead and meets the needs of most applications. but you are free to use anything that <code>limits</code> library supports!</p> <p>sync or async</p> <p><code>limits</code> library supports both sync and async storage backends, but it will be best to use the async version. so you sould import modules from <code>limits.aio</code> for example <code>from limits.aio.storage import MemoryStorage</code>. and if you happen to use the sync version. FastAPI will handle everything as it's documented here.</p> <p>More Storages</p> <p>If you want to know more about different storage backends supported you can refer to limits documentation here.</p> <p>More Strategies</p> <p>If you want to know more about different strategies supported you can refer to limits documentation here.</p>"},{"location":"user-guide/why/","title":"Why?","text":"<p>Why and how FastLimiter works</p> <p>There are some good libraries out there that do the same job as FastLimiter but each of them lack  some very needed functionality.</p> <p>for example there is no simple way to apply limits based on the role of a user.</p> <p>Suppose that we want to set limit for 'admin' users as 100 per minute, but 10 per minute for 'normal users'.</p> <p>if you followed the FastAPI documentation and have for example a <code>get_current_user</code> dependency, why not use that to get the current user? and this is the exact reasoning behind how FastLimiter works, by injecting dependencies.</p> <p>you'll get to know more about how to setup and use FastLimiter in the next chapter.</p>"}]}